<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//keybinds
down_key = vk_left; //change this to change which key cycles down through chat options
up_key = vk_right; //change this to change which key cycles up through chat options
enter_key = vk_space; //change this to change which key selects a chat option
scroll_up = vk_up; //change this to change which key scrolls text up if scrolling is active
scroll_down = vk_down; //change this to change which key scrolls text up if scrolling is active
//set the 3 below keybinds to -1 if you do not want to allow the user to use the keyboard
//to instantly select options
choose_option_1 = ord('1'); //this keybind instantly chooses option 1 when pressed
choose_option_2 = ord('2'); //this keybind instantly chooses option 1 when pressed (if active)
choose_option_3 = ord('3'); //this keybind instantly chooses option 1 when pressed (if active)

//the below variables define how the background to the dialog box should look
text_box_x = 16; //change this to change the top left hand corner of the text box
text_box_y = 160; //change this to change the top left hand corner of the text box
text_box_sprite = -1; //if this is not -1, a sprite is drawn as the background
//if text_box_sprite is not set, a solid colour is used as the text background
//the following two variables define the size on screen of this box
text_box_width = 288; 
text_box_height = 75;
text_box_colour = c_gray; //this is the colour of the solid background if a sprite is not used
text_box_border_colour = c_black; //colour of the border around the solid background
text_box_border_width = 2; //width of border around the solid background (in pixels)
text_box_rounded = true; //if true, creates a rounded box, not square
text_box_rounded_radius = 50; //number of pixels along the x and y axes that should be curved on each corner
text_box_alpha = 1; //used for either the sprite or the background
text_box_view = 0; //if this is set to anything other than -1, the text box will be
                   //drawn with regards to the chosen view's location.
                   
//the following variables define how the text itself should look
text_font = -1;
font_padding = 5; //number of pixels of padding on the text in the box.
//note that padding is from the edge of the outside of the box, including the border
text_colour = c_black; //default colour; note can be changed by using inline effects
text_alpha = 1; //should be pretty obvious by now
text_separation = 15; //number of pixels between each line of text; MUST be at least as large as the height of one line of text
text_shake_speed = 2; //defines how often (in steps) the text shakes if using a shaky modifier (shake or ghosty)
max_lines = 3; //maximum number of lines to draw
scrollable = true; //if true, and if the text overflows then will enable scrolling up and down
mouse_scrolling = true; //if scrolling is active, set to true to allow scrolling with mouse wheel (note - keybinds will still work)
scroll_amount = 1; //number of lines to scroll at a time

//the following variables dictate how the option choosing should look
selector_sprite = spr_selector; //the sprite that shows which option is currently selected
//This is required; to not show a sprite set this to the index of a sprite that is 100% transparent
options_vertical = true; //true sets the options out horizontally, false vertically
//note that if vertical, the options are spaced by the text_separation value above
//if horizontal, the options will be placed in thirds across the text box
options_y = 45; //how far down the text box the options will start (NOTE: ORIGIN IS FROM
//the text_box_y value, NOT absolute.
mouse_choosing = true; //if true, allows the user to click on an option with the mouse to select it
draw_option_outline = true; //if true, draws a square outline around the selected option
option_outline_colour = c_red; //the colour of the outline around the option
option_outline_padding = 2; //number of pixels padding around each option the outline should be
auto_add_numbering = true; //if true, the options will be numbered 1 - 3 automatically

typewriter_speed = 3; //how many steps before a new character is displayed 



//engine variables. Don't touch these
global.game_state = "run";
text = '';
button[0] = '';
button[1] = '';
button[2] = '';
action[0] = '';
action[1] = '';
action[2] = '';
goto[0] = -1;
goto[1] = -1;
goto[2] = -1;
action_selected = 0;
npc = -1;
offset_x = 0;
offset_y = 0;
text_offset_x = 0;
text_offset_y = 0;
text_ghosting = 0;
text_shake_counter = 0;
text_shake_x = 0;
text_shake_y = 0;
typewriter_active = 0;
typewriter_place = 1;
typewriter_timer = 0;
scroll_place = 0;
voice = sound8_durangovoice;
global.dialog = 0;
    view_offset_x = 0;
    view_offset_y = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if we're in text mode, we need to check for keyboard
//input
if(global.dialog == 1)
{

    //get view offsets
    view_offset_x = 0;
    view_offset_y = 0;
    
    if(text_box_view != -1)
    {
        view_offset_x = view_xview[text_box_view];
        view_offset_y = view_yview[text_box_view];
    }
    
    //advance the typewriter if necessary
    if(typewriter_active)
    {
            audio_stop_sound(sound8_durangovoice);
        typewriter_timer += 1;
        if(typewriter_timer = typewriter_speed)
        {
            typewriter_timer = 0;
            typewriter_place += 1;

        }


    }

    //check how many options we have
    var options = 0;
    if(button[2] != '')
        options = 2;
    else if(button[1] != '')
        options = 1;
    
    //set the selected option based on keyboard press
    if(keyboard_check_pressed(up_key))
    {
        action_selected -= 1;
        if(action_selected &lt; 0)
            action_selected = options;
    }
    else if(keyboard_check_pressed(down_key))
    {
        action_selected += 1;
        if(action_selected &gt; options)
            action_selected = 0;
    }
    else if(keyboard_check_pressed(enter_key))
    {
        scr_dialog_activate_selected_option();
    }
    else if (choose_option_1 != -1 &amp;&amp; keyboard_check_pressed(choose_option_1))
    {
        action_selected = 0;
        scr_dialog_activate_selected_option();
    }
    else if (choose_option_2 != -1 &amp;&amp; keyboard_check_pressed(choose_option_2) &amp;&amp; button[1] != '')
    {
        action_selected = 1;
        scr_dialog_activate_selected_option();
    }
    else if (choose_option_3 != -1 &amp;&amp; keyboard_check_pressed(choose_option_3) &amp;&amp; button[2] != '')
    {
        action_selected = 2;
        scr_dialog_activate_selected_option();
    }
    //if scrolling is active, check for scroll input
    if(scrollable)
    {
        if(keyboard_check_pressed(scroll_up) || (mouse_scrolling == true &amp;&amp; mouse_wheel_up()))
        {
            scroll_place -= scroll_amount;
            if(scroll_place &lt; 1) scroll_place = 1;
        }
        else if(keyboard_check_pressed(scroll_down) || (mouse_scrolling == true &amp;&amp; mouse_wheel_down()))
        {
            scroll_place += scroll_amount;
            var lines = max(1, string_count("~", text) - max_lines + 1);
            if(scroll_place &gt; lines) scroll_place = lines;
        }
    
    }
    //if mouse input is active, check for mouse input
    if(mouse_choosing == true)
    {
        
        if(options_vertical)
        {
            if(point_in_rectangle(mouse_x, mouse_y, text_box_x + view_offset_x + font_padding, text_box_y + options_y + view_offset_y + font_padding, text_box_x + view_offset_x + text_box_width + font_padding, text_box_y + options_y + view_offset_y + text_separation - 1 + font_padding))
            {
                action_selected = 0;
            }
            else if(button[1] != '' &amp;&amp; point_in_rectangle(mouse_x, mouse_y, text_box_x + view_offset_x + font_padding, text_box_y + options_y + view_offset_y + text_separation + font_padding, text_box_x + view_offset_x + text_box_width + font_padding, text_box_y + options_y + view_offset_y + text_separation*2 - 1 + font_padding))
            {
                action_selected = 1;
            }
            else if(button[2] != '' &amp;&amp; point_in_rectangle(mouse_x, mouse_y, text_box_x + view_offset_x + font_padding, text_box_y + options_y + view_offset_y + text_separation*2 + font_padding, text_box_x + view_offset_x + text_box_width + font_padding, text_box_y + options_y + view_offset_y + text_separation*3 - 1 + font_padding))
            {
                action_selected = 2;
            }
            if(point_in_rectangle(mouse_x, mouse_y, text_box_x + view_offset_x + font_padding, text_box_y + options_y + view_offset_y + font_padding, text_box_x + view_offset_x + text_box_width + font_padding, text_box_y + options_y + view_offset_y + text_separation*3 - 1 + font_padding)
               &amp;&amp; mouse_check_button_pressed(mb_left))
            {
                scr_dialog_activate_selected_option();
            }
        }
        else
        {   
            var option2_offset = (text_box_width - font_padding*2) / 3;
            var option3_offset = option2_offset*2;
            if(point_in_rectangle(mouse_x, mouse_y, text_box_x + view_offset_x + font_padding, text_box_y + view_offset_y + options_y + font_padding, text_box_x + view_offset_x + option2_offset + font_padding, text_box_y + view_offset_y + options_y + text_separation + font_padding))
            {
                action_selected = 0;
            }
            else if(button[1] != '' &amp;&amp; point_in_rectangle(mouse_x, mouse_y, text_box_x + view_offset_x + option2_offset + font_padding, text_box_y + view_offset_y + options_y + font_padding, text_box_x + view_offset_x + option3_offset + font_padding, text_box_y + view_offset_y + options_y + text_separation + font_padding))
            {
                action_selected = 1;
            }
            else if(button[2] != '' &amp;&amp; point_in_rectangle(mouse_x, mouse_y, text_box_x + view_offset_x + option3_offset + font_padding, text_box_y + view_offset_y + options_y + font_padding, text_box_x + view_offset_x + text_box_width + font_padding, text_box_y + view_offset_y + options_y + text_separation + font_padding))
            {
                action_selected = 2;
            }
            if(point_in_rectangle(mouse_x, mouse_y, text_box_x + view_offset_x + font_padding, text_box_y + options_y + view_offset_y + font_padding, text_box_x + view_offset_x + text_box_width + font_padding, text_box_y + options_y + view_offset_y + text_separation + font_padding)
               &amp;&amp; mouse_check_button_pressed(mb_left))
            {
                scr_dialog_activate_selected_option();
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw the game state if we're in draw mode
if(npc != -1 &amp;&amp; npc != noone)
{
    draw_set_halign(fa_left);
    //initialise drawing parameters
    draw_set_colour(text_box_colour);
    draw_set_alpha(text_box_alpha);
    draw_set_font(text_font);
    text_offset_x = 0;
    text_offset_y = 0;
    text_ghosting = 0;
    //view_offset_x = 0; //moved to step event
    //view_offset_y = 0; //moved to step event
    chars_drawn = 0;
    var temp = '';
    var line = 1;
    
    //check for view offsets; moved to step event
    /*if(text_box_view != -1)
    {
        view_offset_x = view_xview[text_box_view];
        view_offset_y = view_yview[text_box_view];
    }*/
    offset_x = view_offset_x;
    offset_y = view_offset_y;
    
    //draw the background (either sprite or box)
    if(text_box_sprite != -1)
    {
        draw_sprite_ext(text_box_sprite, 0, text_box_x + offset_x, text_box_y + offset_y, 1, 1, 0, c_white, text_box_alpha);
        text_box_width = sprite_get_width(text_box_sprite);
        text_box_height = sprite_get_height(text_box_sprite);
    }
    else if(!text_box_rounded)
    {
        draw_rectangle_colour(text_box_x + offset_x, text_box_y + offset_y, text_box_x + offset_x + text_box_width, text_box_y + offset_y + text_box_height, text_box_border_colour, text_box_border_colour, text_box_border_colour, text_box_border_colour, 0);
        draw_rectangle_colour(text_box_x + offset_x + text_box_border_width, text_box_y + offset_y + text_box_border_width, text_box_x + offset_x + text_box_width - text_box_border_width, text_box_y + offset_y + text_box_height - text_box_border_width, text_box_colour, text_box_colour, text_box_colour, text_box_colour, 0);
    }
    else
    {
        draw_roundrect_colour_ext(text_box_x + offset_x, text_box_y + offset_y, text_box_x + offset_x + text_box_width, text_box_y + offset_y + text_box_height, text_box_rounded_radius, text_box_rounded_radius, text_box_border_colour, text_box_border_colour, 0);
        draw_roundrect_colour_ext(text_box_x + offset_x + text_box_border_width, text_box_y + offset_y + text_box_border_width, text_box_x + offset_x + text_box_width - text_box_border_width, text_box_y + offset_y + text_box_height - text_box_border_width, text_box_rounded_radius, text_box_rounded_radius, text_box_colour, text_box_colour, 0);
    }
    
    //Now actually parse the inputs. Draw each segment (separated by |*|) depending on
    //the input. Note that multiple effects can be piled on top of each other
    offset_x += font_padding;
    offset_y += font_padding;
    draw_set_colour(text_colour);
    drawtext = text;
    var command = '';
    var temp = '';
    
    //loop through each new line, as specified by the ~ delimiter
    do
    {
        if(line &gt;= scroll_place)
        {
            //check for a newline marker. If it exists, grab only the first line
            //to deal with, and chop it out of the main text
            var line_text = '';
            if(string_pos('~', drawtext))
            {
                line_text = string_copy(drawtext, 1, string_pos('~', drawtext) - 1);
            }
            else
            {
                line_text = drawtext;
            }
            //now we loop through and get any text modifiers
            if(string_pos('|', line_text) != 0)
            {
                //run a loop until modifiers aren't found
                var location = string_pos('|', line_text);
                while(location)
                {
                    //if we're not up to a modifer, then draw the text up until the modifier
                    if(location != 1)
                    {
                        temp = scr_dialog_check_typewriter(string_copy(line_text, 1, location - 1));
                        draw_text(text_box_x + offset_x + text_offset_x, text_box_y + offset_y + text_offset_y, temp);
                        if(text_ghosting == 1)
                        {
                            draw_text_colour(text_box_x + offset_x + text_offset_x + text_shake_x*-1, offset_y + text_box_y + text_offset_y + text_shake_y*-1, temp, c_white, c_white, c_white, c_white, 0.5);
                            draw_text_colour(text_box_x + offset_x + text_offset_x + text_shake_x, offset_y + text_box_y + text_offset_y + text_shake_y*2, temp, c_white, c_white, c_white, c_white, 0.25);
                        }
                        if(line_text != '')
                        {
                            line_text = string_delete(line_text, 1, location - 1);
                            text_offset_x += string_width(temp);
                            location = string_pos('|', line_text);
                        }
                    }
                    //if we are at a modifier, grab it, check for another and set the
                    //drawing parameters accordingly
                    else
                    {
                        while(string_pos('|', line_text) == 1)
                        {
                            command = string_copy(line_text, 1, 3);
                            scr_dialog_set_effect(command);
                            line_text = string_delete(line_text, 1, 3);
                        }
                        location = string_pos('|', line_text);
                    }
                }
            }
            //make sure we draw the last bit of text on the line
            temp = scr_dialog_check_typewriter(line_text);
            draw_text(text_box_x + offset_x + text_offset_x, text_box_y + offset_y + text_offset_y, temp);
            if(text_ghosting == 1)
            {
                draw_text_colour(text_box_x + offset_x + text_offset_x + text_shake_x*-1, offset_y + text_box_y + text_offset_y + text_shake_y*-1, temp, c_white, c_white, c_white, c_white, 0.5);
                draw_text_colour(text_box_x + offset_x + text_offset_x + text_shake_x, offset_y + text_box_y + text_offset_y + text_shake_y*2, temp, c_white, c_white, c_white, c_white, 0.25);
            }
            
            //set the new line offset
            text_offset_y += text_separation;
            text_offset_x = 0;
        }
        //remove the drawn line (or not if scrolled past)
        //and set the new line in case we need to scroll
        drawtext = string_delete(drawtext, 1, string_pos('~', drawtext));
        line += 1;
    } until (string_pos('~', drawtext) == 0 || line &gt; max_lines + scroll_place - 1)
    
    //now draw the options
    offset_x = view_offset_x + font_padding;
    offset_y = view_offset_y + font_padding;
    draw_set_colour(text_colour);
    draw_set_alpha(text_alpha);
    selector_width = sprite_get_width(selector_sprite);
    //add numbers to the options?
    if(auto_add_numbering)
    {
        var option1 = "" + button[0];
        var option2 = "" + button[1];
        var option3 = "" + button[2];
    }
    else
    {
        var option1 = button[0];
        var option2 = button[1];
        var option3 = button[2];
    }
    if(options_vertical == false)
    {
        var option2_offset = (text_box_width - font_padding*2) / 3;
        var option3_offset = option2_offset*2;
        //find where the selector is
        if(action_selected == 0)
        {
            draw_sprite(selector_sprite, 0, text_box_x + offset_x, text_box_y + offset_y + options_y);
            if(draw_option_outline)
                draw_rectangle_colour(text_box_x + offset_x - option_outline_padding, text_box_y + offset_y + options_y - option_outline_padding, text_box_x + offset_x + option_outline_padding + selector_width + string_width(option1), text_box_y + offset_y + options_y + option_outline_padding + string_height(option1), option_outline_colour, option_outline_colour, option_outline_colour, option_outline_colour, 1);
        }
        else if(action_selected == 1)
        {
            draw_sprite(selector_sprite, 0, text_box_x + offset_x + option2_offset, text_box_y + offset_y + options_y);
            if(draw_option_outline)
                draw_rectangle_colour(text_box_x + offset_x - option_outline_padding + option2_offset, text_box_y + offset_y + options_y - option_outline_padding, text_box_x + offset_x + option_outline_padding + selector_width + string_width(option2) + option2_offset, text_box_y + offset_y + options_y + option_outline_padding + string_height(option2), option_outline_colour, option_outline_colour, option_outline_colour, option_outline_colour, 1);
        }
        else if(action_selected == 2)
        {
            draw_sprite(selector_sprite, 0, text_box_x + offset_x + option3_offset, text_box_y + offset_y + options_y);
            if(draw_option_outline)
                draw_rectangle_colour(text_box_x + offset_x - option_outline_padding + option3_offset, text_box_y + offset_y + options_y - option_outline_padding, text_box_x + offset_x + option_outline_padding + selector_width + string_width(option3) + option3_offset, text_box_y + offset_y + options_y + option_outline_padding + string_height(option3), option_outline_colour, option_outline_colour, option_outline_colour, option_outline_colour, 1);
        }
            //now draw the options
        draw_text(text_box_x + offset_x + selector_width, text_box_y + offset_y + options_y, option1);
        if(button[1] != '')
            draw_text(text_box_x + offset_x + selector_width + option2_offset, text_box_y + offset_y + options_y, option2);
        if(button[2] != '')
            draw_text(text_box_x + offset_x + selector_width + option3_offset, text_box_y + offset_y + options_y, option3);
    }
    else
    {
        draw_text(text_box_x + offset_x + selector_width, text_box_y + offset_y + options_y, option1)
        if(action_selected == 0)
        {
            draw_sprite(selector_sprite, 0, text_box_x + offset_x, text_box_y + offset_y + options_y);
            if(draw_option_outline)
                draw_rectangle_colour(text_box_x + offset_x - option_outline_padding, text_box_y + offset_y + options_y - option_outline_padding, text_box_x + text_box_width - option_outline_padding - font_padding, text_box_y + offset_y + options_y + option_outline_padding + string_height(option1), option_outline_colour, option_outline_colour, option_outline_colour, option_outline_colour, 1);
        
        }
        if(button[1] != '')
        {
            draw_text(text_box_x + offset_x + selector_width, text_box_y + offset_y + options_y + text_separation, option2)
            if(action_selected == 1)
            {
                draw_sprite(selector_sprite, 0, text_box_x + offset_x, text_box_y + offset_y + options_y + text_separation);
                if(draw_option_outline)
                    draw_rectangle_colour(text_box_x + offset_x - option_outline_padding, text_box_y + offset_y + options_y - option_outline_padding + text_separation, text_box_x + text_box_width - option_outline_padding - font_padding, text_box_y + offset_y + options_y + option_outline_padding + text_separation + string_height(option2), option_outline_colour, option_outline_colour, option_outline_colour, option_outline_colour, 1);
            }
        }
        if(button[2] != '')
        {
            draw_text(text_box_x + offset_x + selector_width, text_box_y + offset_y + options_y + text_separation*2, option3)
            if(action_selected == 2)
            {
                draw_sprite(selector_sprite, 0, text_box_x + offset_x, text_box_y + offset_y + options_y + text_separation*2);
                if(draw_option_outline)
                    draw_rectangle_colour(text_box_x + offset_x - option_outline_padding, text_box_y + offset_y + options_y - option_outline_padding + text_separation*2, text_box_x + text_box_width - option_outline_padding - font_padding, text_box_y + offset_y + options_y + option_outline_padding + text_separation*2 + string_height(option3), option_outline_colour, option_outline_colour, option_outline_colour, option_outline_colour, 1);
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="121">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.nodeath = !global.nodeath;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="120">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.debug) {
global.debug = false;
}
else {
global.debug = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="119">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.debug) {
room_goto(debugscreen);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="118">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.debug) {
game_restart();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
