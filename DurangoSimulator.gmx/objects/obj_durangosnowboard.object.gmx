<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_ingamesnowboard</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>par_player</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Collision Correction

//Moving into a solid puts us back as if we never moved.
//This part allows us to move on slopes and fill the gaps.

//First check if we need to correct for collision
if( speed != 0 and x == xprevious and y == yprevious ){
    
    //get a list of all possible wall objects to collide with
    var colList = move_get_collision_list(obj_wall);

    //move up first if vspeed is up
    if( vspeed &lt; 0 ){
        //update jumpThru state
        update_solid(colList,90,keyboard_check(vk_down));
        move_contact_solid( 90, -vspeed );
    }
    
    //move over if hspeed is not 0
    if( hspeed != 0 ){
        //setting some temporary vars
        var temp_y = y;
        //update jumpThru state
        update_solid(colList,90,keyboard_check(vk_down));
        //move up
        move_contact_solid( 90, abs( hspeed ));

        update_solid(colList,90 - sign( hspeed ) * 90,keyboard_check(vk_down));
        //move over
        move_contact_solid( 90 - sign( hspeed ) * 90, abs( hspeed ));

        update_solid(colList,270,keyboard_check(vk_down));
        //move down what we moved up
        if(temp_y-y != 0){
            move_contact_solid( 270, temp_y-y);
        }
        //move down again if it puts us on ground
        if( !place_free( x, y + abs( hspeed ) + 1 )){
            move_contact_solid( 270, abs( hspeed ));
        }
    }
    //move down if vspeed is down
    if( vspeed &gt; 0 ){
        update_solid(colList,270,keyboard_check(vk_down));
        move_contact_solid( 270, vspeed );
    }
    //if we are blocked then set vspeed to 0
    update_solid(colList,180+90*sign(vspeed),keyboard_check(vk_down));
    if( !place_free( x, y + sign( vspeed ))){
        vspeed = 0;
    }
    //set hspeed to 0 if we can't move horizontally (we're blocked)
    if( hspeed != 0 and x == xprevious ){
        hspeed = 0;
    }
    
    //reset jumpThru states
    reset_solid(colList);
    
    //clean up
    ds_list_destroy(colList);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///standard platform movement

//controls for movement
hkey = keyboard_check( vk_right ) - keyboard_check( vk_left );

//area list to get accurate on ground readings and stuff
var colList = area_get_collision_list(obj_wall);

//update jumpThru state
update_solid(colList,270,keyboard_check(vk_down));

//check if on ground
if( place_free( x, y+1 )){
    gravity = 0.8; //set gravity - we are in the air!
} else {
    gravity = 0; //no need for gravity on ground

    //we are on ground so we can check if we need to jump
    if( keyboard_check_pressed( vk_up )){
        vspeed = -12;
    }
}

//set horizontal movement based on controls
if( hkey == 0 ){
    hspeed *= 0.75; //friction
    if( abs( hspeed ) &lt; 0.5 ){ hspeed = 0; }
} else {
    hspeed *= 0.75;
    hspeed += 2 * sign( hkey );
}

//reset jumpThru states
reset_solid(colList);

//clean up
ds_list_destroy(colList);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
